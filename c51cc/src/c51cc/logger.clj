(ns c51cc.logger
  "Многоуровневая система логирования с гибкой конфигурацией отладочных сообщений.
   Реализует иерархическую модель логирования с четырьмя уровнями детализации.")

(def ^:private debug-levels 
  "Определение иерархии уровней логирования с семантической градацией.
   Каждый последующий уровень включает в себя сообщения предыдущих уровней."
  {:SILENT 0   ; Полное молчание, никакие сообщения не выводятся
   :INFO   1   ; Только важные информационные сообщения
   :DEBUG  2   ; Отладочные сообщения с дополнительным контекстом
   :TRACE  3}) ; Максимально детальная трассировка выполнения

(def ^:dynamic *current-debug-level* 
  "Динамическая переменная для текущего уровня логирования.
   По умолчанию установлен уровень INFO."
  :INFO)

(defn set-debug-level! 
  "Устанавливает глобальный уровень логирования.
   
   Параметры:
   - level: Ключевое слово, определяющее уровень логирования
   
   Возвращает установленный уровень логирования."
  [level]
  (alter-var-root #'*current-debug-level* (constantly level)))

(defn- can-log? 
  "Проверяет, можно ли логировать сообщение с учетом текущего уровня.
   
   Параметры:
   - message-level: Уровень конкретного сообщения
   
   Возвращает булево значение возможности логирования."
  [message-level]
  (<= (get debug-levels message-level)
      (get debug-levels *current-debug-level*)))

(defmacro log 
  "Макрос для условной записи логов с различными уровнями.
   
   Параметры:
   - level: Уровень логирования
   - & body: Тело сообщения для логирования
   
   Макрос выполняет логирование только если уровень сообщения 
   соответствует или ниже текущего глобального уровня."
  [level & body]
  `(when (can-log? ~level)
     (println (str (name ~level) ": " (apply str (map str ~body))))))

(defn trace 
  "Логирование с максимальной детализацией."
  [& messages]
  (when (can-log? :TRACE)
    (println (str "TRACE: " (apply str messages)))))

(defn debug 
  "Логирование отладочных сообщений."
  [& messages]
  (when (can-log? :DEBUG)
    (println (str "DEBUG: " (apply str messages)))))

(defn info 
  "Логирование информационных сообщений."
  [& messages]
  (when (can-log? :INFO)
    (println (str "INFO: " (apply str messages)))))